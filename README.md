# Параллельная быстрая сортировка

## Команды

Запуск тестов: `cargo test`.

Запуск бенчмарка: `cargo run --release`.

## Результаты

В тестировании принимали участие 4 реализации быстрой сортировки:

1. **Последовательная**
2. **Параллельная (свои примитивы, seq memcpy)** - имеет полилогарифмический span (за исключением копирования),
   используются собственные параллельные примитивы, написанные целиком в fork-join модели.
   Для копирования массивов используется последовательный `memcpy`.
3. **Параллельная (свои примитивы, 3-par memcpy)** - имеет полилогарифмический span (за исключением копирования),
   используются собственные параллельные примитивы, написанные целиком в fork-join модели.
   Для копирования массивов используется последовательный `memcpy`, запущенный параллельно в 3 копиях.
4. **Параллельная (свои примитивы, истинный полилогарифм)** - имеет полилогарифмический span,
   используются собственные параллельные примитивы, написанные целиком в fork-join модели.
   Для копирования массивов используется последовательный `memcpy`, запущенный в fork-join модели через `blocked_for`.
5. **Параллельная (примитивы rayon)** - параллельная реализация, использующая `filter` из библиотеки rayon
6. **Параллельная (простая)** - простая параллельная реализация быстрой сортировки в fork-join модели:
   отличается от последовательной тем, что массивы с меньшими и большими элементами сортируются через fork/join.
   Имеет O(n log n) span.

В таблице указано время в миллисекундах и ускорение по сравнению с последовательной реализацией.

Параллельные алгоритмы запускались на 4 потоках.

| Процессор              | Последовательная | Параллельная (свои примитивы, seq memcpy) | Параллельная (свои примитивы, 3-par memcpy) | Параллельная (свои примитивы, истинный полилогарифм) | Параллельная (примитивы rayon) | Параллельная (простая) |
|------------------------|------------------|-------------------------------------------|---------------------------------------------|------------------------------------------------------|--------------------------------|------------------------|
| AMD Ryzen 7 2700X 4GHz | 9418 мс / **1x** | 11264 мс / **0.84x**                      | 11297 мс / **0.83x**                        | 10859 мс / **0.87x**                                 | 6313 мс / **1.49x**            | 2703 мс / **3.48x**    |
| AMD Ryzen 5 5500U      | 8731 мс / **1x** | 13102 мс / **0.67x**                      | 13446 мс / **0.65x**                        | 13229 мс / **0.66x**                                 | 7846 мс / **1.11x**            | 3082 мс / **2.83x**    |
| Apple M3 Max           | 6921 мс / **1x** | 4620 мс / **1.5x**                        | 4589 мс / **1.51x**                         | 4657 мс / **1.49x**                                  | 3536 мс / **1.96x**            | 2103 мс / **3.29x**    |

Параллельная реализация с полилогарифмическим span-ом медленнее всех,
но она и обладает наибольшим work в абсолютном выражении.
При использовании `filter` из rayon, обладающим, скорее всего, большим span-ом, но более эффективным,
получается обогнать последовательный вариант.
Быстрее всех самый простой алгоритм, который обладает в точности тем же work-ом, что и у последовательной версии
(если исключить из рассмотрения накладные расходы fork/join).

А вот параллелизация копирования не дает ускорения (а даже, скорее, небольшое замедление),
так как узким местом здесь становится подсистема памяти, а не вычислительные способности одного ядра.
